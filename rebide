#!/bin/bash

# Rails Development Environment Setup Script
# Sets up tmux, docker services, Sublime Text, and Chrome with custom profile
# Generic version for any Rails project
#
# Configuration: Create a .rebide.conf file in your project root with:
#   CHROME_PROFILE="Profile 1"    # Chrome profile to use (optional)
#   RAILS_PORT="3000"              # Rails server port (default: 3000)
#   CHROME_URL=""                  # Custom URL (default: http://localhost:$RAILS_PORT)
#   RUN_INIT="bin/dev"             # Command to start local server (default: bin/dev)
#   DOCKER_COMPOSE_FILE="docker-compose.yml"  # Docker compose file (default: docker-compose.yml)
#
# Database settings (for dump_db/restore_db commands):
#   DATABASE="postgres"            # Database type: postgres or sqlite3 (default: postgres)
#   DATABASE_HOST="127.0.0.1"      # Database host (default: 127.0.0.1)
#   DATABASE_PORT="5432"           # Database port (default: 5432)
#   DATABASE_USER="postgres"       # Database user (default: postgres)
#   DATABASE_PASSWORD=""           # Database password (optional)
#   DATABASE_DB="myapp_dev"        # Database name or path to sqlite3 file (required)
#   DUMPS_DIR="~/workspace/dumps"  # Directory for DB dumps (default: ~/workspace/dumps)
#
# Environment file settings (for dump_env/restore_env commands):
#   ENVS_DIR="~/workspace/envs"    # Directory for .env backups (default: ~/workspace/envs)

# Version information (date updated automatically by pre-commit hook)
VERSION="1.3"
VERSION_DATE="2025-12-15"

set -e

# Function to find docker-compose file location
find_docker_compose() {
    if [ -f "$PWD/$DOCKER_COMPOSE_FILE" ]; then
        echo "$PWD"
    elif [ -f "$PWD/../$DOCKER_COMPOSE_FILE" ]; then
        echo "$PWD/.."
    else
        echo ""
    fi
}

# Handle version command
if [ "$1" = "version" ]; then
    echo "rebide version $VERSION ($VERSION_DATE)"
    exit 0
fi

# Handle help command
if [ "$1" = "help" ] || [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
    echo "rebide - Rails Development Environment Setup Script"
    echo ""
    echo "Usage: rebide [command] [options]"
    echo ""
    echo "Commands:"
    echo "  (none)            Start full development environment (tmux, Docker, Sublime, Chrome)"
    echo "  serve             Start Docker and run server only (no tmux/Sublime/Chrome)"
    echo "  close             Stop Docker services and kill tmux session"
    echo "  dump_db           Dump PostgreSQL database to dumps/ folder"
    echo "  restore_db [file] Restore PostgreSQL database from dump file"
    echo "  dump_env          Save .env file to ENVS_DIR"
    echo "  restore_env [file] Restore .env file from ENVS_DIR"
    echo "  version           Show version information"
    echo "  list-profiles     List available Chrome profiles"
    echo "  help              Show this help message"
    echo ""
    echo "Options:"
    echo "  --skip-docker     Skip Docker services startup/shutdown"
    echo ""
    echo "Configuration:"
    echo "  Create a .rebide.conf file in your project root with:"
    echo ""
    echo "    CHROME_PROFILE=\"Profile 1\"              # Chrome profile (optional, disables Chrome if not set)"
    echo "    RAILS_PORT=\"3000\"                       # Rails server port (default: 3000)"
    echo "    CHROME_URL=\"http://localhost:3000\"     # Custom URL (default: http://localhost:\$RAILS_PORT)"
    echo "    RUN_INIT=\"bin/dev\"                      # Server start command (default: bin/dev)"
    echo "    DOCKER_COMPOSE_FILE=\"docker-compose.yml\" # Docker compose file (default: docker-compose.yml)"
    echo ""
    echo "  Database settings (for dump_db/restore_db):"
    echo "    DATABASE=\"postgres\"                     # Database type: postgres or sqlite3 (default: postgres)"
    echo "    DATABASE_HOST=\"127.0.0.1\"               # Database host (default: 127.0.0.1)"
    echo "    DATABASE_PORT=\"5432\"                    # Database port (default: 5432)"
    echo "    DATABASE_USER=\"postgres\"                # Database user (default: postgres)"
    echo "    DATABASE_PASSWORD=\"\"                    # Database password (optional)"
    echo "    DATABASE_DB=\"database\"                  # Database name or path to sqlite3 file (required)"
    echo "    DUMPS_DIR=\"~/workspace/dumps\"           # Directory for DB dumps (default: ~/workspace/dumps)"
    echo ""
    echo "  Environment file settings (for dump_env/restore_env):"
    echo "    ENVS_DIR=\"~/workspace/envs\"             # Directory for .env backups (default: ~/workspace/envs)"
    echo ""
    echo "Examples:"
    echo "  rebide                    # Start full environment"
    echo "  rebide serve              # Start server only"
    echo "  rebide close              # Stop environment"
    echo "  rebide --skip-docker      # Start without Docker"
    echo "  rebide serve --skip-docker # Start server without Docker"
    echo "  rebide dump_db            # Dump database to dumps/ folder"
    echo "  rebide restore_db         # List available dumps and select one"
    echo "  rebide restore_db dumps/mydb_2025.sql # Restore specific dump"
    echo "  rebide dump_env           # Save .env to ENVS_DIR"
    echo "  rebide restore_env        # List available .env backups and select one"
    exit 0
fi

# Handle list-profiles command
if [ "$1" = "list-profiles" ]; then
    echo "üìã Available Chrome profiles:"
    echo ""

    local_state="$HOME/.config/google-chrome/Local State"

    if [ -f "$local_state" ] && command -v jq >/dev/null 2>&1; then
        # Use Local State file for accurate profile names
        jq -r '.profile.info_cache | to_entries[] | "\(.key): \(.value.name)"' "$local_state" 2>/dev/null | while read -r line; do
            echo "  $line"
        done
    else
        # Fallback to checking individual Preferences files
        for profile in ~/.config/google-chrome/*/Preferences; do
            if [ -f "$profile" ]; then
                dir=$(dirname "$profile")
                profile_dir=$(basename "$dir")
                if command -v jq >/dev/null 2>&1; then
                    name=$(jq -r '.profile.name // "Unknown"' "$profile" 2>/dev/null)
                    echo "  $profile_dir: $name"
                else
                    echo "  $profile_dir"
                fi
            fi
        done
    fi

    echo ""
    echo "üí° Use these profile directory names (e.g., 'Default', 'Profile 1') in your .chrome-profile file"
    exit 0
fi

# Handle dump_db command
if [ "$1" = "dump_db" ]; then
    echo "üóÑÔ∏è  Dumping database..."

    # Set database defaults
    DATABASE="postgres"
    DATABASE_HOST="127.0.0.1"
    DATABASE_PORT="5432"
    DATABASE_USER="postgres"
    DATABASE_DB=""
    DUMPS_DIR="$HOME/workspace/dumps"

    # Load configuration
    REBIDE_CONF="$PWD/.rebide.conf"
    if [ -f "$REBIDE_CONF" ]; then
        source "$REBIDE_CONF"
    else
        echo "‚ùå Error: .rebide.conf not found"
        exit 1
    fi

    # Validate DATABASE_DB is set
    if [ -z "$DATABASE_DB" ]; then
        echo "‚ùå Error: DATABASE_DB not set in .rebide.conf"
        exit 1
    fi

    # Create dumps directory if it doesn't exist
    mkdir -p "$DUMPS_DIR"

    # Generate dump filename with timestamp
    TIMESTAMP=$(date +"%Y%m%d_%H%M%S")
    if [ "$DATABASE" = "sqlite3" ] || [ "$DATABASE" = "sqlite" ]; then
        # Use project folder name for sqlite3
        DB_NAME=$(basename "$PWD")
    else
        DB_NAME="$DATABASE_DB"
    fi
    DUMP_FILE="$DUMPS_DIR/${DB_NAME}_${TIMESTAMP}.sql"

    echo "üìä Database: $DATABASE_DB"
    echo "üîß Type: $DATABASE"
    echo "üìÅ Output: $DUMP_FILE"

    if [ "$DATABASE" = "sqlite3" ] || [ "$DATABASE" = "sqlite" ]; then
        # Validate sqlite3 file exists
        if [ ! -f "$DATABASE_DB" ]; then
            echo "‚ùå Error: SQLite database file not found: $DATABASE_DB"
            exit 1
        fi

        # Run sqlite3 dump
        sqlite3 "$DATABASE_DB" .dump > "$DUMP_FILE"
    else
        # PostgreSQL dump
        echo "üñ•Ô∏è  Host: $DATABASE_HOST:$DATABASE_PORT"
        echo "üë§ User: $DATABASE_USER"

        PGPASSWORD="${DATABASE_PASSWORD:-}" pg_dump \
            -h "$DATABASE_HOST" \
            -p "$DATABASE_PORT" \
            -U "$DATABASE_USER" \
            -f "$DUMP_FILE" \
            "$DATABASE_DB"
    fi

    if [ $? -eq 0 ]; then
        DUMP_SIZE=$(du -h "$DUMP_FILE" | cut -f1)
        echo "‚úÖ Database dumped successfully ($DUMP_SIZE)"
    else
        echo "‚ùå Error: Database dump failed"
        exit 1
    fi
    exit 0
fi

# Handle restore_db command
if [ "$1" = "restore_db" ]; then
    echo "üóÑÔ∏è  Restoring database..."

    # Set database defaults
    DATABASE="postgres"
    DATABASE_HOST="127.0.0.1"
    DATABASE_PORT="5432"
    DATABASE_USER="postgres"
    DATABASE_DB=""
    DUMPS_DIR="$HOME/workspace/dumps"

    # Load configuration
    REBIDE_CONF="$PWD/.rebide.conf"
    if [ -f "$REBIDE_CONF" ]; then
        source "$REBIDE_CONF"
    else
        echo "‚ùå Error: .rebide.conf not found"
        exit 1
    fi

    # Validate DATABASE_DB is set
    if [ -z "$DATABASE_DB" ]; then
        echo "‚ùå Error: DATABASE_DB not set in .rebide.conf"
        exit 1
    fi

    DUMP_FILE="$2"

    # If no file specified, list available dumps and let user choose
    if [ -z "$DUMP_FILE" ]; then
        if [ ! -d "$DUMPS_DIR" ] || [ -z "$(ls -A "$DUMPS_DIR" 2>/dev/null)" ]; then
            echo "‚ùå Error: No dumps found in $DUMPS_DIR"
            exit 1
        fi

        echo "üìã Available dumps:"
        echo ""

        # List dumps with numbers
        i=1
        declare -a DUMPS
        for dump in "$DUMPS_DIR"/*.sql; do
            if [ -f "$dump" ]; then
                DUMP_SIZE=$(du -h "$dump" | cut -f1)
                DUMP_NAME=$(basename "$dump")
                echo "  $i) $DUMP_NAME ($DUMP_SIZE)"
                DUMPS[$i]="$dump"
                ((i++))
            fi
        done

        if [ ${#DUMPS[@]} -eq 0 ]; then
            echo "‚ùå Error: No .sql files found in $DUMPS_DIR"
            exit 1
        fi

        echo ""
        read -p "Select dump to restore (1-$((i-1))): " SELECTION

        if [[ ! "$SELECTION" =~ ^[0-9]+$ ]] || [ "$SELECTION" -lt 1 ] || [ "$SELECTION" -ge "$i" ]; then
            echo "‚ùå Error: Invalid selection"
            exit 1
        fi

        DUMP_FILE="${DUMPS[$SELECTION]}"
    fi

    # Validate dump file exists
    if [ ! -f "$DUMP_FILE" ]; then
        echo "‚ùå Error: Dump file not found: $DUMP_FILE"
        exit 1
    fi

    echo "üìä Database: $DATABASE_DB"
    echo "üîß Type: $DATABASE"
    echo "üìÅ Restoring from: $DUMP_FILE"

    if [ "$DATABASE" = "sqlite3" ] || [ "$DATABASE" = "sqlite" ]; then
        echo ""
        if [ -f "$DATABASE_DB" ]; then
            echo "‚ö†Ô∏è  This will DELETE and recreate the database file '$DATABASE_DB'"
        else
            echo "üìù Database file will be created: $DATABASE_DB"
        fi
        read -p "Continue? (y/N): " CONFIRM

        if [ "$CONFIRM" != "y" ] && [ "$CONFIRM" != "Y" ]; then
            echo "‚ùå Restore cancelled"
            exit 1
        fi

        # Remove existing database file
        if [ -f "$DATABASE_DB" ]; then
            echo "üîÑ Removing existing database..."
            rm "$DATABASE_DB"
        fi

        echo "üîÑ Restoring data..."
        sqlite3 "$DATABASE_DB" < "$DUMP_FILE"
    else
        # PostgreSQL restore
        echo "üñ•Ô∏è  Host: $DATABASE_HOST:$DATABASE_PORT"
        echo "üë§ User: $DATABASE_USER"
        echo ""
        echo "‚ö†Ô∏è  This will DROP and recreate the database '$DATABASE_DB'"
        read -p "Continue? (y/N): " CONFIRM

        if [ "$CONFIRM" != "y" ] && [ "$CONFIRM" != "Y" ]; then
            echo "‚ùå Restore cancelled"
            exit 1
        fi

        # Drop and recreate database, then restore
        echo "üîÑ Dropping database..."
        PGPASSWORD="${DATABASE_PASSWORD:-}" dropdb \
            -h "$DATABASE_HOST" \
            -p "$DATABASE_PORT" \
            -U "$DATABASE_USER" \
            --if-exists \
            "$DATABASE_DB"

        echo "üîÑ Creating database..."
        PGPASSWORD="${DATABASE_PASSWORD:-}" createdb \
            -h "$DATABASE_HOST" \
            -p "$DATABASE_PORT" \
            -U "$DATABASE_USER" \
            "$DATABASE_DB"

        echo "üîÑ Restoring data..."
        PGPASSWORD="${DATABASE_PASSWORD:-}" psql \
            -h "$DATABASE_HOST" \
            -p "$DATABASE_PORT" \
            -U "$DATABASE_USER" \
            -d "$DATABASE_DB" \
            -f "$DUMP_FILE"
    fi

    if [ $? -eq 0 ]; then
        echo "‚úÖ Database restored successfully"
    else
        echo "‚ùå Error: Database restore failed"
        exit 1
    fi
    exit 0
fi

# Handle dump_env command
if [ "$1" = "dump_env" ]; then
    echo "üìÑ Dumping .env file..."

    # Set default
    ENVS_DIR="$HOME/workspace/envs"

    # Load configuration
    REBIDE_CONF="$PWD/.rebide.conf"
    if [ -f "$REBIDE_CONF" ]; then
        source "$REBIDE_CONF"
    fi

    # Check if .env exists
    if [ ! -f "$PWD/.env" ]; then
        echo "‚ùå Error: .env file not found"
        exit 1
    fi

    # Create envs directory if it doesn't exist
    mkdir -p "$ENVS_DIR"

    # Generate filename with folder name and timestamp
    PROJECT_NAME=$(basename "$PWD")
    TIMESTAMP=$(date +"%Y%m%d_%H%M%S")
    ENV_FILE="$ENVS_DIR/env-${PROJECT_NAME}-${TIMESTAMP}"

    echo "üìÅ Project: $PROJECT_NAME"
    echo "üìÅ Output: $ENV_FILE"

    # Copy .env file
    cp "$PWD/.env" "$ENV_FILE"

    if [ $? -eq 0 ]; then
        ENV_SIZE=$(du -h "$ENV_FILE" | cut -f1)
        echo "‚úÖ .env file saved successfully ($ENV_SIZE)"
    else
        echo "‚ùå Error: Failed to save .env file"
        exit 1
    fi
    exit 0
fi

# Handle restore_env command
if [ "$1" = "restore_env" ]; then
    echo "üìÑ Restoring .env file..."

    # Set default
    ENVS_DIR="$HOME/workspace/envs"

    # Load configuration
    REBIDE_CONF="$PWD/.rebide.conf"
    if [ -f "$REBIDE_CONF" ]; then
        source "$REBIDE_CONF"
    fi

    PROJECT_NAME=$(basename "$PWD")
    ENV_FILE="$2"

    # If no file specified, list available env files and let user choose
    if [ -z "$ENV_FILE" ]; then
        if [ ! -d "$ENVS_DIR" ]; then
            echo "‚ùå Error: Envs directory not found: $ENVS_DIR"
            exit 1
        fi

        # Find env files for this project
        shopt -s nullglob
        ENV_FILES=("$ENVS_DIR"/env-${PROJECT_NAME}-*)
        shopt -u nullglob

        if [ ${#ENV_FILES[@]} -eq 0 ]; then
            echo "‚ùå Error: No env files found for '$PROJECT_NAME' in $ENVS_DIR"
            exit 1
        fi

        echo "üìã Available env files for '$PROJECT_NAME':"
        echo ""

        # List env files with numbers
        i=1
        declare -a ENVS
        for env in "${ENV_FILES[@]}"; do
            if [ -f "$env" ]; then
                ENV_SIZE=$(du -h "$env" | cut -f1)
                ENV_NAME=$(basename "$env")
                echo "  $i) $ENV_NAME ($ENV_SIZE)"
                ENVS[$i]="$env"
                ((i++))
            fi
        done

        echo ""
        read -p "Select env file to restore (1-$((i-1))): " SELECTION

        if [[ ! "$SELECTION" =~ ^[0-9]+$ ]] || [ "$SELECTION" -lt 1 ] || [ "$SELECTION" -ge "$i" ]; then
            echo "‚ùå Error: Invalid selection"
            exit 1
        fi

        ENV_FILE="${ENVS[$SELECTION]}"
    fi

    # Validate env file exists
    if [ ! -f "$ENV_FILE" ]; then
        echo "‚ùå Error: Env file not found: $ENV_FILE"
        exit 1
    fi

    echo "üìÅ Restoring from: $ENV_FILE"

    # Warn if .env already exists
    if [ -f "$PWD/.env" ]; then
        echo "‚ö†Ô∏è  This will overwrite the existing .env file"
        read -p "Continue? (y/N): " CONFIRM

        if [ "$CONFIRM" != "y" ] && [ "$CONFIRM" != "Y" ]; then
            echo "‚ùå Restore cancelled"
            exit 1
        fi
    fi

    # Copy env file
    cp "$ENV_FILE" "$PWD/.env"

    if [ $? -eq 0 ]; then
        echo "‚úÖ .env file restored successfully"
    else
        echo "‚ùå Error: Failed to restore .env file"
        exit 1
    fi
    exit 0
fi

# Parse flags
SKIP_DOCKER=false
for arg in "$@"; do
    case $arg in
        --skip-docker)
            SKIP_DOCKER=true
            shift
            ;;
    esac
done

# Handle serve command (Docker + init command only, no tmux/sublime)
if [ "$1" = "serve" ]; then
    PROJECT_NAME=$(basename "$PWD")
    echo "üöÄ Starting $PROJECT_NAME server..."

    # Set defaults
    CHROME_PROFILE=""
    RUN_INIT="bin/dev"
    RAILS_PORT="3000"
    CHROME_URL=""
    DOCKER_COMPOSE_FILE="docker-compose.yml"

    # Load configuration
    REBIDE_CONF="$PWD/.rebide.conf"
    if [ -f "$REBIDE_CONF" ]; then
        echo "‚öôÔ∏è  Loading configuration from .rebide.conf..."
        source "$REBIDE_CONF"
    fi

    # Set CHROME_URL default if not specified
    if [ -z "$CHROME_URL" ]; then
        CHROME_URL="http://localhost:$RAILS_PORT"
    fi

    # Start Docker services if configured
    if [ "$SKIP_DOCKER" = false ] && [ -n "$DOCKER_COMPOSE_FILE" ]; then
        DOCKER_COMPOSE_DIR=$(find_docker_compose)

        if [ -n "$DOCKER_COMPOSE_DIR" ]; then
            echo "üê≥ Starting Docker services..."
            docker compose -f "$DOCKER_COMPOSE_DIR/$DOCKER_COMPOSE_FILE" up -d
            echo "‚è≥ Waiting for services to start..."
            sleep 3
        else
            echo "‚ö†Ô∏è  No $DOCKER_COMPOSE_FILE found, skipping Docker services"
        fi
    elif [ "$SKIP_DOCKER" = true ]; then
        echo "‚è≠Ô∏è  Skipping Docker services (--skip-docker flag set)"
    elif [ -z "$DOCKER_COMPOSE_FILE" ]; then
        echo "‚è≠Ô∏è  Skipping Docker services (DOCKER_COMPOSE_FILE is empty)"
    fi

    # Open browser if Chrome profile is configured
    if [ -n "$CHROME_PROFILE" ]; then
        echo "üåê Opening Chrome with profile: $CHROME_PROFILE at $CHROME_URL..."
        google-chrome \
            --profile-directory="$CHROME_PROFILE" \
            --new-window \
            --no-first-run \
            --no-default-browser-check \
            "$CHROME_URL" &
    fi

    # Run the init command directly
    echo "üöÄ Running $RUN_INIT..."
    RAILS_PORT=$RAILS_PORT exec $RUN_INIT
fi

# Handle close command
if [ "$1" = "close" ]; then
    PROJECT_NAME=$(basename "$PWD")
    echo "üõë Closing $PROJECT_NAME development environment..."

    # Load configuration to get DOCKER_COMPOSE_FILE
    DOCKER_COMPOSE_FILE="docker-compose.yml"
    REBIDE_CONF="$PWD/.rebide.conf"
    if [ -f "$REBIDE_CONF" ]; then
        source "$REBIDE_CONF"
    fi

    # Stop Docker services only if DOCKER_COMPOSE_FILE is set and not empty
    if [ "$SKIP_DOCKER" = false ] && [ -n "$DOCKER_COMPOSE_FILE" ]; then
        # Find docker-compose file
        DOCKER_COMPOSE_DIR=$(find_docker_compose)

        if [ -n "$DOCKER_COMPOSE_DIR" ]; then
            echo "üê≥ Stopping Docker services..."
            docker compose -f "$DOCKER_COMPOSE_DIR/$DOCKER_COMPOSE_FILE" down
        else
            echo "‚ö†Ô∏è  No $DOCKER_COMPOSE_FILE found, skipping Docker shutdown"
        fi
    elif [ "$SKIP_DOCKER" = true ]; then
        echo "‚è≠Ô∏è  Skipping Docker shutdown (--skip-docker flag set)"
    elif [ -z "$DOCKER_COMPOSE_FILE" ]; then
        echo "‚è≠Ô∏è  Skipping Docker shutdown (DOCKER_COMPOSE_FILE is empty)"
    fi

    # Kill tmux session if it exists
    if tmux has-session -t "$PROJECT_NAME" 2>/dev/null; then
        echo "üì∫ Killing tmux session '$PROJECT_NAME'..."
        tmux kill-session -t "$PROJECT_NAME"
    else
        echo "‚ö†Ô∏è  No tmux session '$PROJECT_NAME' found"
    fi

    echo "‚úÖ Environment closed!"
    exit 0
fi

# Get project name from current directory
PROJECT_NAME=$(basename "$PWD")

# Display banner
echo ""
echo " ‚ñÑ‚ñÑ‚ñÑ ‚ñó‚ñû‚ñÄ‚ñö‚ññ‚ñó‚ññ   ‚ñó‚ñÑ‚ñÑ‚ñÑ‚ññ‚ñó‚ñÑ‚ñÑ‚ñÑ  ‚ñó‚ñÑ‚ñÑ‚ñÑ‚ññ"
echo "‚ñà    ‚ñê‚ñõ‚ñÄ‚ñÄ‚ñò‚ñê‚ñå     ‚ñà  ‚ñê‚ñå  ‚ñà ‚ñê‚ñå   "
echo "‚ñà    ‚ñù‚ñö‚ñÑ‚ñÑ‚ññ‚ñê‚ñõ‚ñÄ‚ñö‚ññ  ‚ñà  ‚ñê‚ñå  ‚ñà ‚ñê‚ñõ‚ñÄ‚ñÄ‚ñò"
echo "          ‚ñê‚ñô‚ñÑ‚ñû‚ñò‚ñó‚ñÑ‚ñà‚ñÑ‚ññ‚ñê‚ñô‚ñÑ‚ñÑ‚ñÄ ‚ñê‚ñô‚ñÑ‚ñÑ‚ññ"
echo ""

echo "üöÄ Starting $PROJECT_NAME development environment..."

# Function to check if command exists
command_exists() {
    command -v "$1" >/dev/null 2>&1
}

# Check required commands
echo "üìã Checking dependencies..."
for cmd in tmux docker subl google-chrome; do
    if ! command_exists "$cmd"; then
        echo "‚ùå Error: $cmd is not installed or not in PATH"
        echo "Please install $cmd and try again"
        exit 1
    fi
done

# Set defaults
CHROME_PROFILE=""
RAILS_PORT="3000"
CHROME_URL=""
RUN_INIT="bin/dev"
DOCKER_COMPOSE_FILE="docker-compose.yml"

# Read configuration from .rebide.conf file
REBIDE_CONF="$PWD/.rebide.conf"
if [ -f "$REBIDE_CONF" ]; then
    echo "‚öôÔ∏è  Loading configuration from .rebide.conf..."
    source "$REBIDE_CONF"
else
    echo "‚öôÔ∏è  No .rebide.conf found, using defaults"
    echo "üí° Create a .rebide.conf file to customize settings"
fi

# Set CHROME_URL default if not specified in config
if [ -z "$CHROME_URL" ]; then
    CHROME_URL="http://localhost:$RAILS_PORT"
fi

# Display configuration
echo "üîå Rails port: $RAILS_PORT"
echo "üöÄ Init command: $RUN_INIT"
if [ -n "$DOCKER_COMPOSE_FILE" ]; then
    echo "üê≥ Docker compose file: $DOCKER_COMPOSE_FILE"
else
    echo "üê≥ Docker: disabled (DOCKER_COMPOSE_FILE is empty)"
fi
if [ -n "$CHROME_PROFILE" ]; then
    echo "üìÅ Chrome profile: $CHROME_PROFILE"
    echo "üåê Chrome URL: $CHROME_URL"
else
    echo "üìÅ Chrome: disabled (no CHROME_PROFILE set)"
fi

# Start Docker services only if DOCKER_COMPOSE_FILE is set and not empty
if [ "$SKIP_DOCKER" = false ] && [ -n "$DOCKER_COMPOSE_FILE" ]; then
    # Find docker-compose file (check current folder, then parent folder)
    DOCKER_COMPOSE_DIR=$(find_docker_compose)
    if [ "$DOCKER_COMPOSE_DIR" = "$PWD" ]; then
        echo "üê≥ Found $DOCKER_COMPOSE_FILE in current directory"
    elif [ "$DOCKER_COMPOSE_DIR" = "$PWD/.." ]; then
        echo "üê≥ Found $DOCKER_COMPOSE_FILE in parent directory"
    elif [ -z "$DOCKER_COMPOSE_DIR" ]; then
        echo "‚ö†Ô∏è  No $DOCKER_COMPOSE_FILE found, skipping Docker services"
    fi

    # Start Docker services if docker-compose file was found
    if [ -n "$DOCKER_COMPOSE_DIR" ]; then
        echo "üê≥ Starting Docker services (database and Redis)..."
        docker compose -f "$DOCKER_COMPOSE_DIR/$DOCKER_COMPOSE_FILE" up -d
    fi
elif [ "$SKIP_DOCKER" = true ]; then
    echo "‚è≠Ô∏è  Skipping Docker services (--skip-docker flag set)"
elif [ -z "$DOCKER_COMPOSE_FILE" ]; then
    echo "‚è≠Ô∏è  Skipping Docker services (DOCKER_COMPOSE_FILE is empty)"
fi

# Wait a moment for services to be ready
echo "‚è≥ Waiting for services to start..."
sleep 3

# Kill existing tmux session if it exists
if tmux has-session -t "$PROJECT_NAME" 2>/dev/null; then
    echo "üîÑ Killing existing tmux session '$PROJECT_NAME'..."
    tmux kill-session -t "$PROJECT_NAME"
fi

# Create new tmux session
echo "üì∫ Creating tmux session '$PROJECT_NAME'..."
tmux new-session -d -s "$PROJECT_NAME" -n main

# Split the window into 3 panes
# Pane 0: claude (top left)
# Pane 1: bash (top right)
# Pane 2: bin/dev (bottom full width)

# Create vertical split (top and bottom)
tmux split-window -v -t "$PROJECT_NAME":main

# Split the top pane horizontally (left and right)
tmux split-window -h -t "$PROJECT_NAME":main.0

# Now we have 3 panes:
# Pane 0 (top left): will run claude
# Pane 1 (top right): bash console
# Pane 2 (bottom): will run bin/dev

# Configure panes
echo "‚öôÔ∏è  Configuring tmux panes..."

# Pane 0: Run claude (top left)
tmux send-keys -t "$PROJECT_NAME":main.0 'echo "Starting Claude Code..."' Enter
tmux send-keys -t "$PROJECT_NAME":main.0 'claude' Enter

# Pane 1: Regular bash console (top right)
tmux send-keys -t "$PROJECT_NAME":main.1 'echo "Ready for commands..."' Enter
tmux send-keys -t "$PROJECT_NAME":main.1 'clear' Enter

# Pane 2: Run init command (bottom) with PORT environment variable
tmux send-keys -t "$PROJECT_NAME":main.2 'echo "Starting Rails development server..."' Enter
tmux send-keys -t "$PROJECT_NAME":main.2 "RAILS_PORT=$RAILS_PORT $RUN_INIT" Enter

# Start Sublime Text
echo "üìù Opening Sublime Text..."
subl "$PWD" &

# Start Chrome with custom profile (only if .chrome-profile exists)
if [ -n "$CHROME_PROFILE" ]; then
    echo "üåê Opening Chrome with profile: $CHROME_PROFILE at $CHROME_URL..."
    google-chrome \
        --profile-directory="$CHROME_PROFILE" \
        --new-window \
        --no-first-run \
        --no-default-browser-check \
        "$CHROME_URL" &
fi

# Wait a moment for applications to start
sleep 2

# Attach to tmux session
echo "‚úÖ Environment ready! Attaching to tmux session..."
echo ""
echo "Tmux panes:"
echo "  - Top left: Claude Code"
echo "  - Top right: Bash console"
echo "  - Bottom: Rails development server ($RUN_INIT)"
echo ""
if [ -n "$CHROME_PROFILE" ]; then
    echo "Chrome profile: $CHROME_PROFILE"
    echo ""
fi
echo "To detach from tmux: Ctrl+B, then D"
echo "To reattach later: tmux attach -t $PROJECT_NAME"
echo ""

tmux attach -t "$PROJECT_NAME"
